<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Harmen Stoppels | Compile-time primes</title>
  <meta name="description" content="Anyone who has seen C++ template meta-programming must have come across the compile-time prime number generator by Erwin Unruh. Since then the language has evolved and provides a very readible alternative. In this post I'll touch on both the classical and modern approach.">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="Compile-time primes">
  <meta property="og:type" content="website">
  <meta property="og:url" content="http://stoppels.blog/posts/compile-time-primes">
  <meta property="og:description" content="Anyone who has seen C++ template meta-programming must have come across the compile-time prime number generator by Erwin Unruh. Since then the language has evolved and provides a very readible alternative. In this post I'll touch on both the classical and modern approach.">
  <meta property="og:site_name" content="Harmen Stoppels">
  <meta property="og:image" content="http://stoppels.blog/assets/og-image-3152b48ed541c1a541e840b64a2e9f39ddae1c07b92cc09fc2ef82e37df9e978.jpg">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:url" content="http://stoppels.blog/posts/compile-time-primes">
  <meta name="twitter:title" content="Compile-time primes">
  <meta name="twitter:description" content="Anyone who has seen C++ template meta-programming must have come across the compile-time prime number generator by Erwin Unruh. Since then the language has evolved and provides a very readible alternative. In this post I'll touch on both the classical and modern approach.">
  <meta name="twitter:image" content="http://stoppels.blog/assets/og-image-3152b48ed541c1a541e840b64a2e9f39ddae1c07b92cc09fc2ef82e37df9e978.jpg">

  <link rel="apple-touch-icon" href="/assets/apple-touch-icon-7dc553f6dd04bd663a8c2f115089d98964c8927dd2750f069cbbdfd984bd5c07.png">
  <link href="http://stoppels.blog/feed.xml" type="application/rss+xml" rel="alternate" title="Harmen Stoppels Last 10 blog posts" />

  

  
    <link type="text/css" rel="stylesheet" href="/assets/light-b9ff8dfb162e24f243ccd6cdc2457522e4bf414e4e1b56010846a53fbfec7fc6.css">
  
</head>

<body>
  <main role="main">
    <div class="grid grid-centered">
      <div class="grid-cell">
        <nav class="header-nav reveal">
  <a href="/" class="header-logo" title="Harmen Stoppels">Harmen Stoppels</a>
  <ul class="header-links">
    
      <li>
        <a href="/about" title="About me">
          <span class="icon icon-android-person"></span>
        </a>
      </li>
    
    
    
    
    
    
    
    
    
    
      <li>
        <a href="/feed.xml" target="_blank" title="RSS">
          <span class="icon icon-social-rss"></span>
        </a>
      </li>
    
  </ul>
</nav>

        <article class="article reveal">
          <header class="article-header">
            <h1>Compile-time primes</h1>
            <p>Anyone who has seen C++ template meta-programming must have come across the compile-time prime number generator by Erwin Unruh. Since then the language has evolved and provides a very readible alternative. In this post I'll touch on both the classical and modern approach.</p>
            <div class="article-list-footer">
              <span class="article-list-date">
                March 10, 2017
              </span>
              <span class="article-list-divider">-</span>
              <span class="article-list-minutes">
                
                
                  9 minute read
                
              </span>
              <span class="article-list-divider">-</span>
              <div class="article-list-tags">
                
                  <a href="/tag/c++">c++</a>
                
              </div>
            </div>
          </header>

          <div class="article-content">
            <p>The building blocks of C++ template meta-programming are usually <code class="highlighter-rouge">struct</code>s without any data members encapsulating a value stored in an <code class="highlighter-rouge">enum</code>. As a simple example consider</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">x</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">MyInteger</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">x</span> <span class="p">};</span>
<span class="p">};</span></code></pre></figure>

<p>This can be used to store an integer as a plain value. It has no address at run-time, since it is not a data member. Storing and retrieving the value is done as follows:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">MyInteger</span><span class="o">&lt;</span><span class="mi">100</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="c1">// prints 100.
</span><span class="p">}</span></code></pre></figure>

<p>Storing and retrieving values is not very exciting, but actually computing something using types <em>is</em>. The simplest way to do so is to exploit recursive definition of types. An instructive example is the Fibonacci sequence:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">x</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">Fibonacci</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span> 
    <span class="n">value</span> <span class="o">=</span> <span class="n">Fibonacci</span><span class="o">&lt;</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">+</span> <span class="n">Fibonacci</span><span class="o">&lt;</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">&gt;::</span><span class="n">value</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">Fibonacci</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Compiling the above will throw errors at us, because the compiler gets stuck in an infinite recursion. This is clearly reflected in the error message, where it shows the compiler quits at depth 256:</p>

<figure class="highlight"><pre><code class="language-none" data-lang="none">fib.cc:6:13: fatal error: recursive template instantiation exceeded maximum depth of 256
    value = Fibonacci&lt;x - 1&gt;::value + Fibonacci&lt;x - 2&gt;::value
            ^
fib.cc:6:13: note: in instantiation of template class 'Fibonacci&lt;18446744073709551370&gt;'
      requested here
fib.cc:6:13: note: in instantiation of template class 'Fibonacci&lt;18446744073709551371&gt;'
      requested here
[...]</code></pre></figure>

<p>Note the overflow in the template parameter, which happens because <code class="highlighter-rouge">size_t</code> is unsigned.</p>

<p>To stop the recursion, we must implement a base case for x = 0 and x = 1. This is done via specialization:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">Fibonacci</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">Fibonacci</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>
<span class="p">};</span></code></pre></figure>

<p>Now the compiler does its job and evaluates <code class="highlighter-rouge">Fibonacci&lt;10&gt;::value</code> to 55, which happens to be the tenth Fibonacci number.</p>

<h2 id="primality-test-using-template-meta-programming">Primality test using template meta-programming</h2>
<p>A trivial primality test for a number p, is to do a linear scan over the numbers 2 to p - 1 and check whether p is divisible by none of them. Of course there are all kinds of improvements to make, but for the sake of simplicity we will not pursue these. We implement the primality test using the following recursion</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">PrimalityTest</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">p</span> <span class="o">%</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">PrimalityTest</span><span class="o">&lt;</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span> <span class="p">};</span> 
<span class="p">};</span> 

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">p</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">PrimalityTest</span><span class="o">&lt;</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">};</span>
<span class="p">};</span></code></pre></figure>

<p>We’re using integers as booleans. The specialization <code class="highlighter-rouge">PrimalityTest&lt;p, 1&gt;</code> guarantees the compiler will not get stuck in infinite recursion limbo. Furthermore, any prime number is of course divisible by 1, so <code class="highlighter-rouge">PrimalityTest&lt;p, 1&gt;::value == 1</code>. For any other <code class="highlighter-rouge">i</code> the value of <code class="highlighter-rouge">PrimalityTest&lt;p, i&gt;::value</code> will be 1 if <code class="highlighter-rouge">p</code> is neither divisible by <code class="highlighter-rouge">i</code> nor by any number less than <code class="highlighter-rouge">i</code>. The latter part is handled recursively.</p>

<p>To call the primality test we can create another struct that does exactly this:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">p</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">IsPrime</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">PrimalityTest</span><span class="o">&lt;</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span> <span class="p">};</span>
<span class="p">};</span></code></pre></figure>

<p>It simply states that a number <code class="highlighter-rouge">p</code> is prime if it is not divisible by any number smaller than <code class="highlighter-rouge">p</code>. A quick sanity check shows that this indeed works:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">IsPrime</span><span class="o">&lt;</span><span class="mi">13</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> 
            <span class="o">&lt;&lt;</span> <span class="n">IsPrime</span><span class="o">&lt;</span><span class="mi">24</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="c1">// outputs 1 0 correctly.
</span><span class="p">}</span></code></pre></figure>

<p>As a concluding remark for this section, a very handy tool to do compile-time testing is <code class="highlighter-rouge">static_assert(bool_constexpr, message)</code> which arrived in C++11. Not only can it be used for testing, but as well to convince yourself it is really the compiler which evaluates an expression. In our example we can use it as follows:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">IsPrime</span><span class="o">&lt;</span><span class="mi">13</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"13 is prime"</span><span class="p">);</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">IsPrime</span><span class="o">&lt;</span><span class="mi">24</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"24 is not prime"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<h2 id="a-modern-alternative-in-c14">A modern alternative in C++14</h2>
<p>Template meta-programming is very powerful, yet as a programming language it generates an enormous cognitive load. Although it sometimes has the looks of a quite mature functional programming language, it also gives the feeling of abuse of what probably is a C++ by-product. Indeed, historically Turing-completeness of the templating system was not a goal, but a welcome surprise.</p>

<p>To make life easier, C++11 introduced the notion of <code class="highlighter-rouge">constexpr</code> functions and variables. This identifier tells the compiler that the value of the function or variable can be evaluated at compile-time. As a simple example, our recursive Fibonacci function can be implemented as a one-liner <code class="highlighter-rouge">constexpr</code> function:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">constexpr</span> <span class="kt">size_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">?</span> <span class="n">n</span> <span class="o">:</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"f(0) == 0"</span><span class="p">);</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"f(1) == 1"</span><span class="p">);</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">55</span><span class="p">,</span> <span class="s">"f(10) == 55"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>This piece of code is almost indistinguishable from the code you would normally write in C++, except for its overdone compactness and recursive inefficiency.</p>

<p>A more efficient implementation would be non-recursive:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">constexpr</span> <span class="kt">size_t</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>

  <span class="kt">size_t</span> <span class="n">previous</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">current</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">previous</span> <span class="o">+</span> <span class="n">current</span><span class="p">;</span>
    <span class="n">previous</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"f(0) == 0"</span><span class="p">);</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"f(1) == 1"</span><span class="p">);</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">55</span><span class="p">,</span> <span class="s">"f(10) == 55"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>However, this piece of code only compiles in C++14. Why? In C++11 <code class="highlighter-rouge">constexpr</code> functions cannot contain variable declarations and should in fact be as simple as a return statement. C++14 has greatly extended the allowed contents of a <code class="highlighter-rouge">constexpr</code> function body, which makes it possible to write code identical to what you would write for compile-time functions.</p>

<h2 id="a-compile-time-prime-sieve-for-counting-prime-numbers">A compile-time prime sieve for counting prime numbers</h2>
<p>As a final example to appreciate the beauty and extend of what <code class="highlighter-rouge">constexpr</code> can do, let’s implement a compile-time prime counting function using the sieve of Eratosthenes. The function <code class="highlighter-rouge">count_primes&lt;N&gt;()</code> returns the number of primes strictly smaller than <code class="highlighter-rouge">N</code>. Using some well-known prime sieving trickery, a relatively efficient implementation is:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">count_primes</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">is_prime</span><span class="p">[</span><span class="n">N</span><span class="p">]{};</span>

  <span class="c1">// Assume all numbers are prime.
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span>
    <span class="n">is_prime</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="c1">// Sieve primes starting at 2.
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_prime</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">multiple</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span> <span class="n">multiple</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">multiple</span> <span class="o">+=</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">is_prime</span><span class="p">[</span><span class="n">multiple</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="c1">// Count primes.
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_prime</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
      <span class="o">++</span><span class="n">total</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s throw some compile-time tests at it for <code class="highlighter-rouge">N</code> as large as 10000:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">count_primes</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">count_primes</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">count_primes</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">count_primes</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">count_primes</span><span class="o">&lt;</span><span class="mi">100</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">==</span> <span class="mi">25</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">count_primes</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1229</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>The above code compiles just fine, which can only mean that <em>the compiler can count prime numbers efficiently in just 22 human-readable lines of code</em>.</p>

<p>Unfortunately we cannot pass <code class="highlighter-rouge">N</code> as a function parameter rather than a template parameter, as <code class="highlighter-rouge">bool is_prime[N]</code> would then be interpreted as a variable-sized object.</p>

<h3 id="can-we-improve-further-what-are-the-limitations">Can we improve further? What are the limitations?</h3>
<p>One idea is to use STL algorithms to initialize the array with <code class="highlighter-rouge">true</code> as values. The problem however is that <code class="highlighter-rouge">std::fill</code> is not (and probably will never be) a <code class="highlighter-rouge">constexpr</code> function. This is because it will resort to <code class="highlighter-rouge">memset</code> to initialize the memory whenever it can.</p>

<p>We could also try to use <code class="highlighter-rouge">std::array</code> as an abstraction, but this has a <code class="highlighter-rouge">constexpr</code> implementation for <code class="highlighter-rouge">operator[](size_t) const</code> only from C++17 onwards. At the time of writing this seems not implemented in Clang 8.0.</p>

<p>A very obvious limitation is of course the possibility of a stack overflow for large values of N, but compile-time computations of that magnitude make probably little sense.</p>

<h2 id="concluding-remarks">Concluding remarks</h2>
<p>C++ has come a long way from the discovery of template meta-programming to the very versatile <code class="highlighter-rouge">constexpr</code> identifier. Even if you’re sceptical about its practical usefulness (which you shouldn’t), the power of the language and in particular its compiler can leave you stunned.</p>


          </div>

          <div class="article-share">
            
            <a href="" title="Share on Twitter" onclick="window.open('https://twitter.com/home?status=Compile-time primes - http://stoppels.blog/posts/compile-time-primes ', 'newwindow', 'width=500, height=225'); return false;" data-turbolinks="false">
              <svg enable-background="new 0 0 128 128" width="15px" version="1.1" viewBox="0 0 128 128" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="_x37__stroke"><g id="Twitter"><rect clip-rule="evenodd" fill="none" fill-rule="evenodd" height="128" width="128"/><path clip-rule="evenodd" d="M128,23.294    c-4.703,2.142-9.767,3.59-15.079,4.237c5.424-3.328,9.587-8.606,11.548-14.892c-5.079,3.082-10.691,5.324-16.687,6.526    c-4.778-5.231-11.608-8.498-19.166-8.498c-14.493,0-26.251,12.057-26.251,26.927c0,2.111,0.225,4.16,0.676,6.133    C41.217,42.601,21.871,31.892,8.91,15.582c-2.261,3.991-3.554,8.621-3.554,13.552c0,9.338,4.636,17.581,11.683,22.412    c-4.297-0.131-8.355-1.356-11.901-3.359v0.331c0,13.051,9.053,23.937,21.074,26.403c-2.201,0.632-4.523,0.948-6.92,0.948    c-1.69,0-3.343-0.162-4.944-0.478c3.343,10.694,13.035,18.483,24.53,18.691c-8.986,7.227-20.315,11.533-32.614,11.533    c-2.119,0-4.215-0.123-6.266-0.37c11.623,7.627,25.432,12.088,40.255,12.088c48.309,0,74.717-41.026,74.717-76.612    c0-1.171-0.023-2.342-0.068-3.49C120.036,33.433,124.491,28.695,128,23.294" fill-rule="evenodd" id="Twitter_1_"/></g></g></svg>
            </a>
            <a href="" title="Share on Facebook" onclick="window.open('https://www.facebook.com/sharer/sharer.php?u=http://stoppels.blog/posts/compile-time-primes', 'newwindow', 'width=500, height=500'); return false;" data-turbolinks="false">
              <svg enable-background="new 0 0 128 128" width="15px" version="1.1" viewBox="0 0 128 128" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="_x31__stroke"><g id="Facebook_1_"><rect fill="none" height="128" width="128"/><path clip-rule="evenodd" d="M68.369,128H7.065C3.162,128,0,124.836,0,120.935    V7.065C0,3.162,3.162,0,7.065,0h113.871C124.837,0,128,3.162,128,7.065v113.87c0,3.902-3.163,7.065-7.064,7.065H88.318V78.431    h16.638l2.491-19.318H88.318V46.78c0-5.593,1.553-9.404,9.573-9.404l10.229-0.004V20.094c-1.769-0.235-7.841-0.761-14.906-0.761    c-14.749,0-24.846,9.003-24.846,25.535v14.246H51.688v19.318h16.681V128z" fill-rule="evenodd" id="Facebook"/></g></g></svg>
            </a>
            <a href="" title="Share on Google+" onclick="window.open('https://plus.google.com/share?url=http://stoppels.blog/posts/compile-time-primes', 'newwindow', 'width=550, height=400'); return false;" data-turbolinks="false">
              <svg enable-background="new 0 0 128 128" version="1.1" viewBox="0 0 128 128" width="20px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="_x35__stroke"><g id="Google_Plus"><rect clip-rule="evenodd" fill="none" fill-rule="evenodd" height="128" width="128"/><path clip-rule="evenodd" d="M40.654,55.935v16.13    c0,0,15.619-0.021,21.979-0.021C59.189,82.5,53.834,88.194,40.654,88.194c-13.338,0-23.748-10.832-23.748-24.194    s10.41-24.194,23.748-24.194c7.052,0,11.607,2.483,15.784,5.944c3.344-3.35,3.065-3.828,11.573-11.877    c-7.222-6.586-16.822-10.6-27.357-10.6C18.201,23.273,0,41.507,0,64c0,22.493,18.201,40.727,40.654,40.727    c33.561,0,41.763-29.275,39.044-48.792H40.654z M113.912,56.742V42.628h-10.063v14.113H89.358v10.081h14.491v14.517h10.063V66.823    H128V56.742H113.912z" fill-rule="evenodd" id="Google_Plus_1_"/></g></g></svg>
            </a>
          </div>

          
        </article>
        <footer class="footer">
  <p>Copyright © Harmen Stoppels 2016 - 2017</p>
</footer>

      </div>
    </div>
  </main>
  

<script type="text/javascript" src="/assets/vendor-520b491499ff5614f88d8f4acacadb719e8fa40ef2c1170283bf17b55ef65489.js"></script>
<script type="text/javascript" src="/assets/application-f1029296017765c33dacda0445d0df196b36bb28ac75032f2b9014da07ea47a7.js"></script>

</body>
</html>
