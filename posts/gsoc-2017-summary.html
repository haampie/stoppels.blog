<!doctype html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="x-ua-compatible" content="ie=edge"> <title>GSOC 2017 summary | Harmen Stoppels</title> <meta name="description" content="As GSOC 2017 is coming to an end, I'd like to use this blog post to give a summary of the things I have been working on."> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta property="og:title" content="GSOC 2017 summary"> <meta property="og:type" content="website"> <meta property="og:url" content="http://localhost:4000/posts/gsoc-2017-summary"> <meta property="og:description" content="As GSOC 2017 is coming to an end, I'd like to use this blog post to give a summary of the things I have been working on."> <meta property="og:site_name" content="Harmen Stoppels"> <meta property="og:image" content="http://localhost:4000/assets/logo.png"> <meta property="og:image:type" content="image/png"> <meta property="og:image:width" content="1200"> <meta property="og:image:height" content="630"> <meta name="twitter:card" content="summary"> <meta name="twitter:url" content="http://localhost:4000/posts/gsoc-2017-summary"> <meta name="twitter:title" content="GSOC 2017 summary"> <meta name="twitter:description" content="As GSOC 2017 is coming to an end, I'd like to use this blog post to give a summary of the things I have been working on."> <meta name="twitter:image" content="http://localhost:4000/assets/logo.png"> <link rel="apple-touch-icon" href="/assets/touch-icon.png"> <link href="http://localhost:4000/feed.xml" type="application/rss+xml" rel="alternate" title="Harmen Stoppels Last 10 blog posts"/> <style>html{font-family:sans-serif;line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,footer,header,nav{display:block}h1{font-size:2em;margin:0.67em 0}figure,main{display:block}figure{margin:1em 40px}pre{font-family:monospace, monospace;font-size:1em}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}code{font-family:monospace, monospace;font-size:1em}img{border-style:none}svg:not(:root){overflow:hidden}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}*,*::before,*::after{-webkit-box-sizing:border-box;box-sizing:border-box}html{font-size:16px}body{margin:0 auto;font-family:Arial, Helvetica, sans-serif;-webkit-font-smoothing:antialiased;font-weight:400;line-height:1.8;color:#615b5b;background:#fff1e0}p{margin:0;font-weight:400}h1,h2,h3,h4{margin:0;line-height:1.5;text-rendering:optimizeLegibility}h1{font-size:25.6px;font-weight:400;letter-spacing:-.03em;color:#121111}h2{font-size:24px;font-weight:400}h3{font-size:20.8px;font-weight:500}h4{font-size:17.6px;font-weight:500}@media all and (max-width: 767px){h1{font-size:24px}h2{font-size:21.6px}h3{font-size:20px}}a{color:#615b5b;text-decoration:underline;-webkit-transition:color 0.2s linear;transition:color 0.2s linear}a:hover,a:active{color:#393636}a:focus{color:#393636;outline:none}ul{padding-left:40px;margin:0}img{display:block;max-width:100%;margin:0}::-moz-selection{color:#fff;background-color:#121111}::selection{color:#fff;background-color:#121111}.footer{display:block;padding:35px 0 85px;border-top:1px solid rgba(0,0,0,0.1)}.footer p{font-size:15px;color:#ada8a8}.grid{display:block;padding:0;margin:0 -20px;font-size:0;text-align:left}.grid-cell{display:inline-block;width:100%;padding:0 20px;margin:0;font-size:16px;text-align:left;vertical-align:top}.grid-centered{max-width:650px;margin-right:auto;margin-left:auto}.article{display:block;margin:100px 0}.article-list-footer{display:block}.article-list-footer span,.article-list-footer a{display:inline-block;font-size:12px;color:#888181;text-transform:uppercase;vertical-align:middle}.article-list-footer a{margin-right:7.5px;color:#615b5b}.article-list-footer a:hover{color:#121111}.article-list-footer a:last-child{margin-right:0}.article-list-divider{margin:0 15px}.article-list-tags{display:inline-block;vertical-align:top}.article-header{display:block;padding-bottom:30px;margin-bottom:30px;border-bottom:1px solid rgba(0,0,0,0.1)}.article-header p{display:block;margin:12px 0 10px;font-size:15px;color:#615b5b}.article-header a{text-decoration:none}.article-content{display:block}.article-content p,.article-content ul,.article-content img{display:block;margin-bottom:30px}.article-content h2,.article-content h3,.article-content h4{display:block;margin-bottom:10px;font-family:Arial, Helvetica, sans-serif;color:#121111}.article-share{display:block;margin-top:-4px}.article-share a{display:inline-block;margin-right:12px;vertical-align:middle}.article-share a svg{vertical-align:middle;-webkit-transition:fill 0.2s linear;transition:fill 0.2s linear;fill:#ada8a8}.article-share a:hover svg{fill:#615b5b}@media all and (max-width: 767px){.article-list-footer{display:block}.article-list-divider:last-of-type{display:none}.article-list-tags{display:block;margin-top:-7px}}.full_width_fig{width:100vw;position:relative;-webkit-transform:translate(-50%);transform:translate(-50%);left:50%;text-align:center;background:white;border-top:1px solid #e7e7e7;border-bottom:1px solid #e7e7e7;padding:3rem 0;margin:3rem 0}.full_width_fig img{display:inline;margin:0}.header-nav{display:block;padding:75px 0 20px;border-bottom:1px solid rgba(0,0,0,0.1)}.header-logo{display:inline-block;font-family:"Palatino Linotype", "Book Antiqua", Palatino, serif;font-size:36px;font-weight:700;color:#000;text-decoration:none}.header-links{float:right;padding:0;margin:15px 0 0;list-style:none}.header-links li{display:inline-block;margin-left:20px;vertical-align:middle}.header-links li:first-child{margin-left:0}.header-links li a{font-size:18px;color:#393636}.header-links li a:hover{color:#121111}@media all and (max-width: 415px){.header-nav{text-align:center}.header-links{display:block;float:none;text-align:center}.header-links li{margin:0 10px}.header-links li:last-child{margin-right:0}}.highlight{padding:50px;margin:0;margin:30px 0;overflow:auto;font-weight:400;background:#f3dec8;-webkit-box-shadow:0 2px 0.2px rgba(0,0,0,0.1);box-shadow:0 2px 0.2px rgba(0,0,0,0.1)}.highlight pre{margin:0}.highlighter-rouge{padding:2px 4px;font-size:14px;background:#f3dec8;border:1px solid rgba(0,0,0,0.1);border-radius:1px}@media all and (max-width: 767px){.highlight{padding:50px 25px;font-size:14px}}.highlight .c{font-style:italic;color:#998}.highlight .k{font-weight:bold}.highlight .o{font-weight:bold}.highlight .kt{font-weight:bold;color:#458}.highlight .s{color:#d14}.highlight .nb{color:#0086b3}.highlight .nf{font-weight:bold;color:#900}.highlight .mf{color:#099}.highlight .mi{color:#099}.icon{display:inline-block;width:1em;height:1em;stroke-width:0;stroke:currentColor;fill:currentColor}.icon-ion-social-rss{width:0.75em}.icon-ion-android-person{width:0.75em}</style> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css"> </head> <body> <main role="main"> <div class="grid grid-centered"> <div class="grid-cell"> <nav class="header-nav reveal"> <a href="/" class="header-logo" title="Harmen Stoppels">Harmen Stoppels</a> <ul class="header-links"> <li> <a href="/about" title="About me"> <svg class="icon icon-ion-android-person"><use xlink:href="#icon-ion-android-person"></use></svg> </a> </li> <li> <a href="/feed.xml" target="_blank" title="RSS"> <svg class="icon icon-ion-social-rss"><use xlink:href="#icon-ion-social-rss"></use></svg> </a> </li> </ul> </nav> <article class="article reveal"> <header class="article-header"> <h1>GSOC 2017 summary</h1> <p>As GSOC 2017 is coming to an end, I'd like to use this blog post to give a summary of the things I have been working on.</p> <div class="article-list-footer"> <span class="article-list-date"> August 18, 2017 </span> <span class="article-list-divider">-</span> <span class="article-list-minutes"> 13 minute read </span> <span class="article-list-divider">-</span> <div class="article-list-tags"> <a href="/tag/gsoc">gsoc</a> <a href="/tag/julia">julia</a> </div> </div> </header> <div class="article-content"> <p>The central part of my GSOC project concerns implementing the Jacobi-Davidson method natively in Julia, available in <a href="https://github.com/haampie/JacobiDavidson.jl">JacobiDavidson.jl</a>. This method computes a few approximate solutions of the eigenvalue problem <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>λ</mi><mi>B</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Ax = \lambda Bx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathit">λ</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit">x</span></span></span></span> for large matrices <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>. As it uses iterative solvers internally, much time has gone into improving <a href="https://github.com/JuliaMath/IterativeSolvers.jl">IterativeSolvers.jl</a> in general. Lastly, as iterative solvers are typically used with preconditioners, I have implemented the incomplete LU factorization for sparse matrices as well in <a href="https://github.com/haampie/ILU.jl">ILU.jl</a>.</p> <h2 id="jacobidavidsonjl"><a href="https://github.com/haampie/JacobiDavidson.jl">JacobiDavidson.jl</a></h2> <p>The Jacobi-Davidson implementation is ready for use and can be applied to solving the (generalized) eigenvalue problem for non-Hermitian matrices. It’s similar to the <code class="highlighter-rouge">eigs</code> method already available in Julia: you can get a couple eigenvalues near a specified target in the complex plane.</p> <p>The <code class="highlighter-rouge">jdqr</code> function computes a partial Schur decomposition <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>Q</mi><mo>=</mo><mi>Q</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">AQ = QR </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit">Q</span><span class="mrel">=</span><span class="mord mathit">Q</span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span> of a general matrix <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span></span></span></span>. The columns of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">Q</span></span></span></span> are orthonormal Schur vectors, and the diagonal of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span> contains the eigenvalues of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span></span></span></span>. Working with Schur vectors is numerically more stable than working with eigenvectors, but eigenvectors can be computed from the Schur vectors when necessary.</p> <p>For the generalized problem we have the <code class="highlighter-rouge">jdqz</code> function that computes a partial generalized Schur decomposition <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>Z</mi><mo>=</mo><mi>Q</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">AZ = QS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit" style="margin-right:0.07153em;">Z</span><span class="mrel">=</span><span class="mord mathit">Q</span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>Z</mi><mo>=</mo><mi>Q</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">BZ = QT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit" style="margin-right:0.07153em;">Z</span><span class="mrel">=</span><span class="mord mathit">Q</span><span class="mord mathit" style="margin-right:0.13889em;">T</span></span></span></span> for a matrix pencil <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(A, B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">A</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>. Here <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">Q</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.07153em;">Z</span></span></span></span> have orthonormal columns and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span></span></span></span> upper triangular. The eigenvalues <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\lambda_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">λ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><msub><mi>λ</mi><mi>k</mi></msub><mi>B</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Ax = \lambda_k Bx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">λ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit">x</span></span></span></span> can be found by computing <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mo>=</mo><mfrac><mrow><msub><mi>S</mi><mrow><mi>k</mi><mi>k</mi></mrow></msub></mrow><mrow><msub><mi>T</mi><mrow><mi>k</mi><mi>k</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">\lambda_k = \frac{S_{kk}}{T_{kk}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.894191em;"></span><span class="strut bottom" style="height:1.3450509999999998em;vertical-align:-0.4508599999999999em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">λ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15122857142857138em;margin-right:0.07142857142857144em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.41585999999999995em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15122857142857138em;margin-right:0.07142857142857144em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span>.</p> <p>At this point no official release has been tagged yet, as there is still some work to be done: hopefully the <code class="highlighter-rouge">jdqr</code> and <code class="highlighter-rouge">jdqz</code> methods can largely be merged as they are very similar; there are some optimizations for Hermitian problems that aren’t yet implemented; and lastly the methods do not yet support generic vectors and numbers.</p> <p>For an example of <code class="highlighter-rouge">jdqz</code> see the last section of this post.</p> <h2 id="iterativesolversjl"><a href="https://github.com/JuliaMath/IterativeSolvers.jl">IterativeSolvers.jl</a></h2> <p>My contributions to IterativeSolvers.jl include</p> <ul> <li>improving speed and memory usage in <a href="https://github.com/JuliaMath/IterativeSolvers.jl/pull/131">GMRES</a>, <a href="https://github.com/JuliaMath/IterativeSolvers.jl/pull/130">CG</a>, <a href="https://github.com/JuliaMath/IterativeSolvers.jl/pull/145">Chebyshev iteration</a>, the <a href="https://github.com/JuliaMath/IterativeSolvers.jl/pull/139">power method</a> and stationary methods mentioned below.</li> <li>adding missing iterative methods <a href="https://github.com/JuliaMath/IterativeSolvers.jl/pull/148">MINRES</a> and <a href="https://github.com/JuliaMath/IterativeSolvers.jl/pull/134">BiCGStab(l)</a>;</li> <li>implementing stationary methods for sparse matrices <a href="https://github.com/JuliaMath/IterativeSolvers.jl/pull/156">#156</a>;</li> <li>upgrading the package to Julia 0.6 and thereby <a href="https://github.com/JuliaMath/IterativeSolvers.jl/pull/150">updating the tests</a>;</li> <li>improving and restructuring <a href="https://github.com/JuliaMath/IterativeSolvers.jl/pull/157">the documentation</a>.</li> </ul> <h2 id="ilujl"><a href="https://github.com/haampie/ILU.jl">ILU.jl</a></h2> <p>Computing the full LU decomposition of a large, sparse matrix requires too much memory and computational work. By simply dropping small terms during the LU factorization these problems can be remedied, at the expense of being inexact or incomplete (ILU). This ILU factorization can still be an excellent preconditioner to speed up iterative methods.</p> <p>As ILU for the <code class="highlighter-rouge">SparseMatrixCSC</code> type was not yet available in Julia, I’ve implemented it based on the article “Crout versions of ILU for general sparse matrices” by Na Li, Yousef Saad and Edmond Chow.</p> <p>The package is completely ready for use and is well tested. See below for an example.</p> <p>In a later version the package can be improved by adding different dropping strategies.</p> <h2 id="examples">Examples</h2> <p>Below you can find a few examples on how to use the packages I’ve been working on.</p> <h3 id="jacobi-davidson">Jacobi-Davidson</h3> <p>Let’s take a look at a toy example of the generalized eigenvalue problem <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>λ</mi><mi>B</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Ax = \lambda Bx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathit">λ</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit">x</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> are diagonal matrices of size <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mbin">×</span><span class="mord mathit">n</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>k</mi><mi>k</mi></mrow></msub><mo>=</mo><msqrt><mrow><mi>k</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">A_{kk} = \sqrt{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.93222em;"></span><span class="strut bottom" style="height:1.08222em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="sqrt mord"><span class="sqrt-sign" style="top:-0.09221999999999997em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span style="top:-0.85222em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mrow><mi>k</mi><mi>k</mi></mrow></msub><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><msqrt><mrow><mi>k</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">B_{kk} = 1 / \sqrt{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.93222em;"></span><span class="strut bottom" style="height:1.18222em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05017em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">/</span><span class="sqrt mord"><span class="sqrt-sign" style="top:-0.09221999999999997em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span style="top:-0.85222em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span></span></span></span>. The eigenvalues are just the integers <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1, \cdots, n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="minner">⋯</span><span class="mpunct">,</span><span class="mord mathit">n</span></span></span></span>.</p> <p>We implement the action of the matrices <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span> matrix-free, using LinearMaps.jl:</p> <figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="n">using</span> <span class="n">LinearMaps</span>

<span class="k">function</span><span class="nf"> myA</span><span class="o">!</span><span class="x">(</span><span class="n">y</span><span class="x">,</span> <span class="n">x</span><span class="x">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="x">:</span> <span class="n">length</span><span class="x">(</span><span class="n">x</span><span class="x">)</span>
    <span class="nd">@inbounds</span> <span class="n">y</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="x">(</span><span class="n">i</span><span class="x">)</span> <span class="o">*</span> <span class="n">x</span><span class="x">[</span><span class="n">i</span><span class="x">]</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> myB</span><span class="o">!</span><span class="x">(</span><span class="n">y</span><span class="x">,</span> <span class="n">x</span><span class="x">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="x">:</span> <span class="n">length</span><span class="x">(</span><span class="n">x</span><span class="x">)</span>
    <span class="nd">@inbounds</span> <span class="n">y</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">=</span> <span class="n">x</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">/</span> <span class="n">sqrt</span><span class="x">(</span><span class="n">i</span><span class="x">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">LinearMap</span><span class="x">{</span><span class="kt">Complex128</span><span class="x">}(</span><span class="n">myA!</span><span class="x">,</span> <span class="n">n</span><span class="x">;</span> <span class="n">ismutating</span> <span class="o">=</span> <span class="n">true</span><span class="x">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">LinearMap</span><span class="x">{</span><span class="kt">Complex128</span><span class="x">}(</span><span class="n">myB!</span><span class="x">,</span> <span class="n">n</span><span class="x">;</span> <span class="n">ismutating</span> <span class="o">=</span> <span class="n">true</span><span class="x">)</span></code></pre></figure> <p>Next we fix <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">n = 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span>, set the number of requested eigenpairs to 5 and target the eigenvalues with largest real part, somewhere near <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>1</mn><mn>0</mn><mi mathvariant="normal">.</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">110.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">.</span><span class="mord mathrm">0</span></span></span></span>. We use a couple steps of BiCGStab(2) as an internal iterative solver, and set the dimension of the search space from 5 to 10 vectors:</p> <figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="n">using</span> <span class="n">JacobiDavidson</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">LR</span><span class="x">(</span><span class="mf">110.0</span> <span class="o">+</span> <span class="mf">0.0</span><span class="nb">im</span><span class="x">)</span> <span class="c"># Largest Real part</span>

<span class="n">schur</span><span class="x">,</span> <span class="n">resnorms</span> <span class="o">=</span> <span class="n">jdqz</span><span class="x">(</span><span class="n">A</span><span class="x">,</span> <span class="n">B</span><span class="x">,</span> 
    <span class="n">bicgstabl_solver</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">max_mv_products</span> <span class="o">=</span> <span class="mi">10</span><span class="x">,</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">2</span><span class="x">),</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="x">,</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="mi">5</span><span class="x">,</span>
    <span class="n">ɛ</span> <span class="o">=</span> <span class="mf">1e-9</span><span class="x">,</span>
    <span class="n">min_dimension</span> <span class="o">=</span> <span class="mi">5</span><span class="x">,</span>
    <span class="n">max_dimension</span> <span class="o">=</span> <span class="mi">10</span><span class="x">,</span>
    <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">100</span><span class="x">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">true</span>
<span class="x">)</span>

<span class="n">println</span><span class="o">.</span><span class="x">(</span><span class="n">schur</span><span class="o">.</span><span class="n">alphas</span> <span class="o">./</span> <span class="n">schur</span><span class="o">.</span><span class="n">betas</span><span class="x">)</span>
<span class="n">plot</span><span class="x">(</span><span class="n">resnorms</span><span class="x">,</span> <span class="n">yscale</span> <span class="o">=</span> <span class="x">:</span><span class="n">log10</span><span class="x">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="x">:</span><span class="o">+</span><span class="x">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">"Residual norm"</span><span class="x">,</span> <span class="n">xlabel</span> <span class="o">=</span> <span class="s">"Iteration"</span><span class="x">)</span></code></pre></figure> <p>It indeed finds the eigenvalues from 96 up to 100:</p> <figure class="highlight"><pre><code class="language-text" data-lang="text">100.00000000000041 + 5.329070518200757e-14im
98.99999999999996 - 1.7674527390216706e-14im
98.00000000000013 - 3.542337114695263e-14im
97.00000000000024 + 1.749508591650104e-14im
96.00000000000013 + 1.3053503572900918e-14im</code></pre></figure> <p>The plot shows the convergence history, which is the residual norm <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∥</mi><mi>A</mi><mi>x</mi><mo>−</mo><mi>λ</mi><mi>B</mi><mi>x</mi><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">\|Ax - \lambda Bx\|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∥</span><span class="mord mathit">A</span><span class="mord mathit">x</span><span class="mbin">−</span><span class="mord mathit">λ</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathit">x</span><span class="mord mathrm">∥</span></span></span></span> in each iteration:</p> <figure class="full_width_fig"> <img src="/assets/summary/residualnorm.svg" alt="summary/residualnorm.svg"/> </figure> <h4 id="preconditioning">Preconditioning</h4> <p>The problem gets harder when we increase <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> a few orders of magnitude. Especially if we want to target eigenvalues in the interior of the spectrum (near <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mord mathrm">/</span><span class="mord mathrm">2</span></span></span></span>), GMRES and BiCGStab(l) might have trouble solving a very indefinite system.</p> <p>In that case a preconditioner for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>A</mi><mo>−</mo><mi>τ</mi><mi>B</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(A - \tau B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">A</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.1132em;">τ</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span> can be used, where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.1132em;">τ</span></span></span></span> is the target. We will just use the exact inverse, which is a diagonal matrix <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span> with entries <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mrow><mi>k</mi><mi>k</mi></mrow></msub><mo>=</mo><msqrt><mrow><mi>k</mi></mrow></msqrt><mi mathvariant="normal">/</mi><mo>(</mo><mi>k</mi><mo>−</mo><mi>τ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P_{kk} = \sqrt{k} / (k - \tau)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.93222em;"></span><span class="strut bottom" style="height:1.18222em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="sqrt mord"><span class="sqrt-sign" style="top:-0.09221999999999997em;"><span class="style-wrap reset-textstyle textstyle uncramped">√</span></span><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span style="top:-0.85222em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped sqrt-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mathrm">/</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.1132em;">τ</span><span class="mclose">)</span></span></span></span>.</p> <p>It can be implemented matrix-free and in-place:</p> <figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="k">import</span> <span class="n">Base</span><span class="o">.</span><span class="n">LinAlg</span><span class="o">.</span><span class="n">A_ldiv_B!</span>

<span class="n">struct</span> <span class="n">SuperPreconditioner</span><span class="x">{</span><span class="n">numT</span> <span class="o">&lt;:</span> <span class="n">Number</span><span class="x">}</span>
    <span class="n">target</span><span class="o">::</span><span class="n">numT</span>
<span class="k">end</span>

<span class="k">function</span><span class="nf"> A_ldiv_B</span><span class="o">!</span><span class="x">(</span><span class="n">p</span><span class="o">::</span><span class="n">SuperPreconditioner</span><span class="x">,</span> <span class="n">x</span><span class="x">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="x">:</span> <span class="n">length</span><span class="x">(</span><span class="n">x</span><span class="x">)</span>
        <span class="nd">@inbounds</span> <span class="n">x</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">*=</span> <span class="n">sqrt</span><span class="x">(</span><span class="n">i</span><span class="x">)</span> <span class="o">/</span> <span class="x">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">p</span><span class="o">.</span><span class="n">target</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span></code></pre></figure> <p>Now we call Jacobi-Davidson with the <code class="highlighter-rouge">Near</code> target and pass the preconditioner. This time we use GMRES, but BiCGStab works as well.</p> <figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="n">n</span> <span class="o">=</span> <span class="mi">100_000</span>
<span class="n">τ</span> <span class="o">=</span> <span class="mf">50_000.1</span> <span class="o">+</span> <span class="mi">0</span><span class="nb">im</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">Near</span><span class="x">(</span><span class="n">τ</span><span class="x">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">LinearMap</span><span class="x">{</span><span class="kt">Complex128</span><span class="x">}(</span><span class="n">myA!</span><span class="x">,</span> <span class="n">n</span><span class="x">;</span> <span class="n">ismutating</span> <span class="o">=</span> <span class="n">true</span><span class="x">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">LinearMap</span><span class="x">{</span><span class="kt">Complex128</span><span class="x">}(</span><span class="n">myB!</span><span class="x">,</span> <span class="n">n</span><span class="x">;</span> <span class="n">ismutating</span> <span class="o">=</span> <span class="n">true</span><span class="x">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">SuperPreconditioner</span><span class="x">(</span><span class="n">τ</span><span class="x">)</span>

<span class="n">schur</span><span class="x">,</span> <span class="n">residuals</span> <span class="o">=</span> <span class="n">jdqz</span><span class="x">(</span><span class="n">A</span><span class="x">,</span> <span class="n">B</span><span class="x">,</span> 
    <span class="n">gmres_solver</span><span class="x">(</span><span class="n">n</span><span class="x">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">10</span><span class="x">),</span>
    <span class="n">preconditioner</span> <span class="o">=</span> <span class="n">P</span><span class="x">,</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="x">,</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="mi">5</span><span class="x">,</span>
    <span class="n">ɛ</span> <span class="o">=</span> <span class="mf">1e-9</span><span class="x">,</span>
    <span class="n">min_dimension</span> <span class="o">=</span> <span class="mi">5</span><span class="x">,</span>
    <span class="n">max_dimension</span> <span class="o">=</span> <span class="mi">10</span><span class="x">,</span>
    <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">200</span><span class="x">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">true</span>
<span class="x">)</span></code></pre></figure> <p>It converges to the eigenvalues 49999, 50000, 50001, 50002 and 50004:</p> <figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="mf">50004.00000000014</span> <span class="o">+</span> <span class="mf">3.5749921718300463e-12</span><span class="nb">im</span>
<span class="mf">49999.999999986496</span> <span class="o">-</span> <span class="mf">7.348301591250897e-12</span><span class="nb">im</span>
<span class="mf">50001.00000000359</span> <span class="o">-</span> <span class="mf">1.9761169705101647e-11</span><span class="nb">im</span>
<span class="mf">49998.99999999998</span> <span class="o">-</span> <span class="mf">1.0866253642291695e-10</span><span class="nb">im</span>
<span class="mf">50002.00000000171</span> <span class="o">-</span> <span class="mf">2.3559720511618024e-11</span><span class="nb">im</span></code></pre></figure> <p>It does not yet detect 50003, but that might happen when <code class="highlighter-rouge">pairs</code> is increased a bit. What is more interesting is that the total number of iterations is small as a result of the preconditioner:</p> <figure class="full_width_fig"> <img src="/assets/summary/residualnorm_2.svg" alt="summary/residualnorm_2.svg"/> </figure> <p>It’s not easy to construct a preconditioner this good for any given problem, but usually people tend to know what works well in specific classes of problems. If no specific preconditioner is availabe, you can always try a general one such as ILU. The next section illustrates that.</p> <h3 id="ilu-example">ILU example</h3> <p>As an example of how ILU can be used we generate a non-symmetric, banded matrix having a structure that typically arises in finite differences schemes of three-dimensional problems:</p> <figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="n">n</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">n</span><span class="o">^</span><span class="mi">3</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">spdiagm</span><span class="x">((</span><span class="n">fill</span><span class="x">(</span><span class="o">-</span><span class="mf">1.0</span><span class="x">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="x">),</span> <span class="n">fill</span><span class="x">(</span><span class="mf">3.0</span><span class="x">,</span> <span class="n">n</span><span class="x">),</span> <span class="n">fill</span><span class="x">(</span><span class="o">-</span><span class="mf">2.0</span><span class="x">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="x">)),</span> <span class="x">(</span><span class="o">-</span><span class="mi">1</span><span class="x">,</span> <span class="mi">0</span><span class="x">,</span> <span class="mi">1</span><span class="x">))</span>
<span class="n">Id</span> <span class="o">=</span> <span class="n">speye</span><span class="x">(</span><span class="n">n</span><span class="x">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">kron</span><span class="x">(</span><span class="n">A</span><span class="x">,</span> <span class="n">Id</span><span class="x">)</span> <span class="o">+</span> <span class="n">kron</span><span class="x">(</span><span class="n">Id</span><span class="x">,</span> <span class="n">A</span><span class="x">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">kron</span><span class="x">(</span><span class="n">A</span><span class="x">,</span> <span class="n">Id</span><span class="x">)</span> <span class="o">+</span> <span class="n">kron</span><span class="x">(</span><span class="n">Id</span><span class="x">,</span> <span class="n">A</span><span class="x">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">ones</span><span class="x">(</span><span class="n">N</span><span class="x">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">x</span></code></pre></figure> <p>The matrix <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span></span></span></span> has size <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><msup><mn>4</mn><mn>3</mn></msup><mo>×</mo><mn>6</mn><msup><mn>4</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">64^3 \times 64^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">6</span><span class="mord"><span class="mord mathrm">4</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord mathrm">6</span><span class="mord"><span class="mord mathrm">4</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>. We want to solve the problem <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">Ax = b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">A</span><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathit">b</span></span></span></span> using for instance BiCGStab(2), but it turns out that convergence can get slow when the size of the problem grows. A quick benchmark shows it takes about 2.0 seconds to solve the problem to a reasonable tolerance:</p> <figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="o">&gt;</span> <span class="n">using</span> <span class="n">BenchmarkTools</span><span class="x">,</span> <span class="n">IterativeSolvers</span>
<span class="o">&gt;</span> <span class="n">my_x</span> <span class="o">=</span> <span class="nd">@btime</span> <span class="n">bicgstabl</span><span class="x">(</span><span class="o">$</span><span class="n">A</span><span class="x">,</span> <span class="o">$</span><span class="n">b</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="n">max_mv_products</span> <span class="o">=</span> <span class="mi">2000</span><span class="x">);</span>
<span class="mf">2.051</span> <span class="n">s</span>
<span class="o">&gt;</span> <span class="n">norm</span><span class="x">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">A</span> <span class="o">*</span> <span class="n">my_x</span><span class="x">)</span> <span class="o">/</span> <span class="n">norm</span><span class="x">(</span><span class="n">b</span><span class="x">)</span>
<span class="mf">1.6967043606691152e-9</span></code></pre></figure> <p>Now let’s construct the incomplete LU decomposition:</p> <figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="o">&gt;</span> <span class="n">using</span> <span class="n">ILU</span>
<span class="o">&gt;</span> <span class="n">LU</span> <span class="o">=</span> <span class="n">crout_ilu</span><span class="x">(</span><span class="n">A</span><span class="x">,</span> <span class="n">τ</span> <span class="o">=</span> <span class="mf">0.1</span><span class="x">)</span>
<span class="o">&gt;</span> <span class="n">nnz</span><span class="x">(</span><span class="n">LU</span><span class="x">)</span> <span class="o">/</span> <span class="n">nnz</span><span class="x">(</span><span class="n">A</span><span class="x">)</span>
<span class="mf">2.1180353639352374</span></code></pre></figure> <p>Using the above drop tolerance <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.1132em;">τ</span></span></span></span>, we get an approximate LU decomposition using only about twice as many entries as the original matrix, which is reasonable. Let’s see what happens when we benchmark the solver again, now with ILU as a preconditioner:</p> <figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="o">&gt;</span> <span class="n">my_x</span> <span class="o">=</span> <span class="nd">@btime</span> <span class="n">bicgstabl</span><span class="x">(</span><span class="o">$</span><span class="n">A</span><span class="x">,</span> <span class="o">$</span><span class="n">b</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="n">Pl</span> <span class="o">=</span> <span class="o">$</span><span class="n">LU</span><span class="x">,</span> <span class="n">max_mv_products</span> <span class="o">=</span> <span class="mi">2000</span><span class="x">);</span>
<span class="mf">692.187</span> <span class="n">ms</span>
<span class="o">&gt;</span> <span class="n">norm</span><span class="x">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">A</span> <span class="o">*</span> <span class="n">my_x</span><span class="x">)</span> <span class="o">/</span> <span class="n">norm</span><span class="x">(</span><span class="n">b</span><span class="x">)</span>
<span class="mf">2.133397068536056e-9</span></code></pre></figure> <p>It solves the problem 66% faster to the same tolerance. There is of course a caveat, as constructing the preconditioner itself takes time as well:</p> <figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="o">&gt;</span> <span class="n">LU</span> <span class="o">=</span> <span class="nd">@btime</span> <span class="n">crout_ilu</span><span class="x">(</span><span class="o">$</span><span class="n">A</span><span class="x">,</span> <span class="n">τ</span> <span class="o">=</span> <span class="mf">0.1</span><span class="x">);</span>
<span class="mf">611.019</span> <span class="n">ms</span></code></pre></figure> <p>So all in all the problem is solved about 36% faster. However, if we have multiple right-hand sides for the same matrix, we can construct the preconditioner only once and use it multiple times. Even when the matrix changes slightly you could reuse the ILU factorization. The latter is exactly what happens in Jacobi-Davidson.</p> </div> <div class="article-share"> <a href="" title="Share on Twitter" onclick="window.open('https://twitter.com/home?status=GSOC 2017 summary - http://localhost:4000/posts/gsoc-2017-summary ', 'newwindow', 'width=500, height=225'); return false;" data-turbolinks="false"> <svg enable-background="new 0 0 128 128" width="15px" version="1.1" viewBox="0 0 128 128" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="_x37__stroke"><g id="Twitter"><rect clip-rule="evenodd" fill="none" fill-rule="evenodd" height="128" width="128"/><path clip-rule="evenodd" d="M128,23.294 c-4.703,2.142-9.767,3.59-15.079,4.237c5.424-3.328,9.587-8.606,11.548-14.892c-5.079,3.082-10.691,5.324-16.687,6.526 c-4.778-5.231-11.608-8.498-19.166-8.498c-14.493,0-26.251,12.057-26.251,26.927c0,2.111,0.225,4.16,0.676,6.133 C41.217,42.601,21.871,31.892,8.91,15.582c-2.261,3.991-3.554,8.621-3.554,13.552c0,9.338,4.636,17.581,11.683,22.412 c-4.297-0.131-8.355-1.356-11.901-3.359v0.331c0,13.051,9.053,23.937,21.074,26.403c-2.201,0.632-4.523,0.948-6.92,0.948 c-1.69,0-3.343-0.162-4.944-0.478c3.343,10.694,13.035,18.483,24.53,18.691c-8.986,7.227-20.315,11.533-32.614,11.533 c-2.119,0-4.215-0.123-6.266-0.37c11.623,7.627,25.432,12.088,40.255,12.088c48.309,0,74.717-41.026,74.717-76.612 c0-1.171-0.023-2.342-0.068-3.49C120.036,33.433,124.491,28.695,128,23.294" fill-rule="evenodd" id="Twitter_1_"/></g></g></svg> </a> <a href="" title="Share on Facebook" onclick="window.open('https://www.facebook.com/sharer/sharer.php?u=http://localhost:4000/posts/gsoc-2017-summary', 'newwindow', 'width=500, height=500'); return false;" data-turbolinks="false"> <svg enable-background="new 0 0 128 128" width="15px" version="1.1" viewBox="0 0 128 128" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="_x31__stroke"><g id="Facebook_1_"><rect fill="none" height="128" width="128"/><path clip-rule="evenodd" d="M68.369,128H7.065C3.162,128,0,124.836,0,120.935 V7.065C0,3.162,3.162,0,7.065,0h113.871C124.837,0,128,3.162,128,7.065v113.87c0,3.902-3.163,7.065-7.064,7.065H88.318V78.431 h16.638l2.491-19.318H88.318V46.78c0-5.593,1.553-9.404,9.573-9.404l10.229-0.004V20.094c-1.769-0.235-7.841-0.761-14.906-0.761 c-14.749,0-24.846,9.003-24.846,25.535v14.246H51.688v19.318h16.681V128z" fill-rule="evenodd" id="Facebook"/></g></g></svg> </a> <a href="" title="Share on Google+" onclick="window.open('https://plus.google.com/share?url=http://localhost:4000/posts/gsoc-2017-summary', 'newwindow', 'width=550, height=400'); return false;" data-turbolinks="false"> <svg enable-background="new 0 0 128 128" version="1.1" viewBox="0 0 128 128" width="20px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="_x35__stroke"><g id="Google_Plus"><rect clip-rule="evenodd" fill="none" fill-rule="evenodd" height="128" width="128"/><path clip-rule="evenodd" d="M40.654,55.935v16.13 c0,0,15.619-0.021,21.979-0.021C59.189,82.5,53.834,88.194,40.654,88.194c-13.338,0-23.748-10.832-23.748-24.194 s10.41-24.194,23.748-24.194c7.052,0,11.607,2.483,15.784,5.944c3.344-3.35,3.065-3.828,11.573-11.877 c-7.222-6.586-16.822-10.6-27.357-10.6C18.201,23.273,0,41.507,0,64c0,22.493,18.201,40.727,40.654,40.727 c33.561,0,41.763-29.275,39.044-48.792H40.654z M113.912,56.742V42.628h-10.063v14.113H89.358v10.081h14.491v14.517h10.063V66.823 H128V56.742H113.912z" fill-rule="evenodd" id="Google_Plus_1_"/></g></g></svg> </a> </div> </article> <footer class="footer"> <p>Copyright © Harmen Stoppels 2016 - 2017</p> </footer> </div> </div> </main> <script>
window.ga=function(){ga.q.push(arguments)};ga.q=[];ga.l=+new Date;
ga('create','UA-93471447-1','auto');ga('send','pageview')
</script> <script src="https://www.google-analytics.com/analytics.js" async defer></script> </body> </html>